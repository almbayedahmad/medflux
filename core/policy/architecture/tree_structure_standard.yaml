meta:
  version: 6
  id: tree_structure_comprehensive
  updated_at: '2025-01-15T13:00:00Z'
  notes: Comprehensive architecture standard covering all folder structures, naming conventions,
    pipeline architecture, cross-phase code classification, and migration strategies for both
    existing and new code. Includes complete decision trees and validation rules.

structural_evolution:
  version_2_0_0:
    date: "2025-01-08"
    changes:
      - "Moved canonical policies to core/policy/ as single source of truth"
      - "Eliminated duplicate docs/ directories from phase roots"
      - "Consolidated all documentation to common_files/docs/"
      - "Removed ~110 template files with placeholders"
      - "Standardized naming across all phases (00-10)"
      - "Created phase_generator.py for automated phase creation"
      - "Updated schema naming pattern to <stage>_schema_<type>.py"
      - "Implemented minimal phase structure approach"
    benefits:
      - "Single source of truth for all phase files"
      - "Reduced duplication from 11 copies to 1 source"
      - "Cleaner minimal phase structure"
      - "Easier maintenance and updates"
      - "Centralized control of project-wide standards"

tree_structure:
  # === ARCHITECTURE OVERVIEW ===
  architecture_overview:
    system_purpose: "Multi-phase document preprocessing pipeline with standardized structure and contract-driven interfaces"
    execution_model: "Sequential phases (00, 01, 02...) with defined contracts between stages"
    key_principles:
      - "Separation of concerns: business logic vs orchestration vs I/O"
      - "Layer-based organization: phase-specific vs cross-phase code"
      - "Contract-driven interfaces between phases"
      - "Standardized structure for consistency and maintainability"
      - "Pure functions preferred for testability"
      - "Configuration-driven behavior over hardcoded values"

    layer_architecture:
      phase_layer:
        description: "Code specific to a single phase lives INSIDE that phase directory"
        folders: ["phase_XX_<stage>/core_functions/", "phase_XX_<stage>/pipeline_workflow/", "phase_XX_<stage>/schemas/", "phase_XX_<stage>/tests/"]
        decision_question: "Will this code be reused by more than one phase?"
        if_no: "Place in phase-specific folder"

      main_layer:
        description: "Code reused across MULTIPLE phases lives in the core preprocessing layer"
        folders: ["core/preprocessing/cross_phase/helpers/", "core/preprocessing/cross_phase/schemas/", "core/preprocessing/pipeline/", "backend/Preprocessing/main_pre_tests/"]
        decision_question: "Will this code be reused by more than one phase?"
        if_yes: "Place in main-layer folder"

  # === CROSS-PHASE CODE CLASSIFICATION ===
  cross_phase_code_classification:
    principle: "Any code used by more than one phase belongs in main folders, organized by purpose and action"

    main_folder_structure:
      main_pre_helpers:
        purpose: "Reusable utility functions across phases"
        naming_pattern: "main_pre_helpers_<topic>.py"
        examples:
          - "main_pre_helpers_lang.py"      # Language processing utilities
          - "main_pre_helpers_logger.py"    # Logging utilities
          - "main_pre_helpers_geom.py"      # Geometry utilities
          - "main_pre_helpers_image.py"    # Image processing utilities
          - "main_pre_helpers_num.py"       # Number processing utilities
          - "main_pre_helpers_lang_detect.py" # Language detection utilities
        responsibilities:
          - "Pure utility functions"
          - "No business logic"
          - "No external dependencies"
          - "Stateless operations"

      main_pre_pipeline:
        purpose: "Multi-phase orchestration and coordination"
        naming_pattern: "<purpose>_pipeline.py"
        examples:
          - "preprocessing_chain.py"        # Full pipeline chain
          - "detect_and_read.py"           # Partial pipeline chain
          - "smoke_test_pipeline.py"       # Testing pipeline
          - "validation_pipeline.py"       # Validation pipeline
        responsibilities:
          - "Coordinate phase execution order"
          - "Pass data between phases"
          - "Handle cross-phase errors"
          - "Manage overall pipeline state"
          - "Provide unified CLI interface"

      main_pre_schemas:
        purpose: "Shared data structures and contracts"
        naming_pattern: "<entity>_schema.py"
        examples:
          - "document_meta_schema.py"      # Document metadata schema
          - "stage_contract_schema.py"     # Stage contract definitions
          - "pipeline_config_schema.py"    # Pipeline configuration schema
          - "output_format_schema.py"      # Output format definitions
        responsibilities:
          - "Define data contracts"
          - "Validate data structures"
          - "Provide type definitions"
          - "Ensure consistency across phases"

      cross_phase_config:
        purpose: "Global configuration and rules"
        naming_pattern: "<topic>_config.yaml"
        examples:
          - "preprocessing_rules.yaml"      # Global preprocessing rules
          - "pipeline_config.yaml"         # Pipeline configuration
          - "validation_rules.yaml"        # Global validation rules
          - "logging_config.yaml"          # Logging configuration
        responsibilities:
          - "Define global settings"
          - "Configure cross-phase behavior"
          - "Set validation rules"
          - "Manage feature flags"

      main_pre_output:
        purpose: "Cross-phase output management and routing"
        naming_pattern: "<functionality>_router.py"
        examples:
          - "output_router.py"            # Output directory management
          - "result_aggregator.py"         # Result aggregation
          - "export_manager.py"            # Export functionality
        responsibilities:
          - "Manage output directories"
          - "Route outputs to correct locations"
          - "Aggregate results from multiple phases"
          - "Handle output formatting"
          - "Store smoke/integration artifacts under MEDFLUX_OUTPUT_ROOT (or <repo>/outputs/preprocessing) and allow per-run overrides"

      main_pre_tests:
        purpose: "Cross-phase integration and system tests"
        naming_pattern: "test_<topic>.py"
        examples:
          - "test_pipeline_integration.py" # Pipeline integration tests
          - "test_cross_phase_contracts.py" # Contract validation tests
          - "test_main_pre_helpers_lang.py" # Helper function tests
          - "test_output_routing.py"       # Output routing tests
        responsibilities:
          - "Test cross-phase integration"
          - "Validate system contracts"
          - "Test helper functions"
          - "Ensure end-to-end functionality"

      main_pre_samples:
        purpose: "Sample data and test files"
        naming_pattern: "<type>_samples/"
        examples:
          - "pdf_samples/"                  # PDF sample files
          - "docx_samples/"                # DOCX sample files
          - "image_samples/"               # Image sample files
          - "smoke_samples/"               # Smoke test samples
        responsibilities:
          - "Provide test data"
          - "Support development and testing"
          - "Enable reproducible testing"
          - "Document expected formats"

      policy_source:
        purpose: "Canonical project-wide standards, policies, and development guidelines"
        location: "core/policy/"
        naming_pattern: "<category>/<topic>_<type>.md or .yaml"
        subdirectories:
          development:
            purpose: "Phase creation guides and automation"
            files:
              - "core/policy/developer_setup/phase_scaffolding_guide.md"
              - "core/policy/developer_setup/development_checklist.md"
              - "backend/Preprocessing/main_pre_standards/development/phase_generator.py"
          documentation:
            purpose: "Documentation and naming standards"
            files:
              - "core/policy/documentation/docs_conventions.yaml"
              - "core/policy/documentation/language_policy.yaml"
              - "core/policy/documentation/naming_standards.md"
          git:
            purpose: "Git workflow and commit standards"
            files:
              - "core/policy/git/commit_conventions.md"
              - "core/policy/git/git_rules.md"
          policies:
            purpose: "Contract and validation templates"
            files:
              - "core/policy/contracts/stage_contract.yaml"
              - "core/policy/validation/validation_rules.yaml"
              - "core/policy/observability/kpis.yaml"
          versioning:
            purpose: "Versioning policies and standards"
            files:
              - "core/policy/versioning/schema_versioning.md"
              - "core/policy/versioning/versioning_policy.md"
        benefits:
          - "Centralized control of all project-wide standards"
          - "Eliminated ~110 duplicate template files across 11 phases"
          - "Single source of truth for policies"
          - "Easier maintenance and updates"
        responsibilities:
          - "Define project-wide development standards"
          - "Provide phase creation automation"
          - "Centralize documentation conventions"
          - "Manage git workflow policies"
          - "Define validation and contract templates"
        notes:
          - "Legacy backend/Preprocessing/main_pre_* packages remain as shims; new cross-phase code must live in core/preprocessing/‚Ä¶"

  # === PIPELINE ARCHITECTURE ===
  pipeline_architecture:
    single_phase_pipelines:
      location: "phase_XX_<stage>/pipeline_workflow/"
      naming_pattern: "<stage>_pipeline.py"
      purpose: "Orchestrate within a single phase (config ‚Üí connectors ‚Üí core_functions ‚Üí outputs)"
      scope: "Single phase only"
      examples:
        - "readers_pipeline.py"
        - "detect_type_pipeline.py"
        - "encoding_pipeline.py"
      responsibilities:
        - "Load phase configuration"
        - "Connect to upstream data"
        - "Call core functions"
        - "Save outputs"
        - "Handle phase-level errors"

    multi_phase_pipelines:
      location: "core/preprocessing/pipeline/"
      naming_pattern: "<purpose>_pipeline.py"
      purpose: "Chain multiple phases together for end-to-end processing"
      scope: "Cross-phase coordination"
      examples:
        - "preprocessing_chain.py"  # Chains phases 00 ‚Üí 01 ‚Üí 02
        - "detect_and_read.py"      # Chains phases 00 ‚Üí 02
        - "full_pipeline.py"        # Chains all phases
      responsibilities:
        - "Coordinate phase execution order"
        - "Pass data between phases"
        - "Handle cross-phase errors"
        - "Manage overall pipeline state"
        - "Provide unified CLI interface"

  # === PHASE EXECUTION ORDER ===
  phase_execution_order:
    phase_00_detect_type: "Document type detection and classification"
    phase_01_encoding: "Content encoding and format detection"
    phase_02_readers: "Content extraction from various document types"
    phase_03_merge: "Document merging and consolidation"
    phase_04_cleaning: "Data cleaning and preprocessing"
    phase_05_light_normalization: "Light text normalization"
    phase_06_segmentation: "Document segmentation and structure analysis"
    phase_07_table_extraction: "Table extraction and processing"
    phase_08_heavy_normalization: "Heavy text normalization"
    phase_09_provenance: "Provenance tracking and metadata"
    phase_10_offsets: "Offset calculation and indexing"
    execution_model: "Sequential execution with contract validation between phases"
    failure_handling: "Failed phases stop the pipeline with clear error reporting"

  # === DEPENDENCIES ===
  dependencies:
    phase_dependencies:
      phase_01_encoding: [phase_00_detect_type]
      phase_02_readers: [phase_01_encoding]
      phase_03_merge: [phase_02_readers]
      phase_04_cleaning: [phase_03_merge]
      phase_05_light_normalization: [phase_04_cleaning]
      phase_06_segmentation: [phase_05_light_normalization]
      phase_07_table_extraction: [phase_06_segmentation]
      phase_08_heavy_normalization: [phase_07_table_extraction]
      phase_09_provenance: [phase_08_heavy_normalization]
      phase_10_offsets: [phase_09_provenance]
    shared_dependencies:
      python_version: "3.8+"
      core_libraries:
        - "Pydantic for schemas and validation"
        - "PyYAML for configuration files"
        - "pytest for testing framework"
        - "logging for structured logging"
      optional_libraries:
        - "OCR libraries for document processing"
        - "PDF processing libraries"
        - "Database adapters for persistence"

  # === ERROR HANDLING ===
  error_handling:
    phase_level:
      strategy: "Each phase handles its own errors and provides meaningful error messages"
      error_types:
        - "Input validation errors"
        - "Processing errors"
        - "External service failures"
        - "Configuration errors"
      response: "Log error details and return structured error response"
    system_level:
      strategy: "Failed phases stop the pipeline with clear error reporting"
      error_propagation: "Phase errors bubble up with context preservation"
      recovery: "Manual intervention required for failed phases"
    error_format:
      structure: "Standardized error response with error type, message, context, and suggestions"
      logging: "Structured logging with correlation IDs for debugging"

  # === UNIFIED FOLDER STRUCTURE ===
  unified_folder_structure:
    phase_directory_pattern: "phase_XX_<stage>"
    required_subfolders:
      - "üìë config"           # YAML/JSON settings; feature flags; routing maps
      - "‚öôÔ∏è pipeline_workflow" # Single-phase orchestration; step ordering; validation
      - "üîó connecters"        # External I/O: APIs, DB adapters, storage clients
      - "üß† core_functions"   # Business logic for the phase (STANDARDIZED NAME)
      - "üóÇ schemas"          # Typed contracts and validators
      - "üì§ outputs"          # Official/standard results of this phase
      - "üõ† internal_helpers" # Local utilities scoped to this phase only
      - "üß™ tests"            # Unit/integration/contract tests
      - "üìö docs"             # Human-readable docs: README, runbooks, diagrams
      - "üñº assets"           # Static non-code resources
      - "‚ôªÔ∏è external_helpers" # Reusable utilities across phases
      - "üóÉ common_files"     # Shared static artifacts

    migration_notes:
      core_processors_to_core_functions: "Phases 00-01 use 'core_processors/' - migrate to 'core_functions/' for consistency"
      folder_standardization: "All phases should use identical folder structure"

  # === UNIFIED NAMING CONVENTIONS ===
  unified_naming_conventions:
    file_naming_rules:
      phase_layer:
        core_functions:
          pattern: "<stage>_core_<functionality>.py"
          description: "Phase-specific business logic modules"
          examples:
            - "readers_core_pdf.py"
            - "readers_core_ocr.py"
            - "detect_type_core_classifier.py"  # Future migration from core_processors
            - "encoding_core_normalizer.py"      # Future migration from core_processors

        pipeline_workflow:
          pattern: "<stage>_pipeline.py"
          description: "Phase orchestration/entry modules"
          examples:
            - "readers_pipeline.py"
            - "detect_type_pipeline.py"
            - "encoding_pipeline.py"

        connecters:
          pattern: "<stage>_connector_<type>.py"
          description: "External I/O adapters"
          examples:
            - "readers_connector_config.py"
            - "readers_connector_upstream.py"
            - "detect_type_config_connector.py"

        schemas:
          pattern: "<stage>_schema_<type>.py"
          description: "Phase-scoped type definitions and schemas"
          examples:
            - "readers_schema_types.py"      # Main type definitions
            - "readers_schema_output.py"     # Output schema
            - "readers_schema_models.py"     # Runtime models
            - "readers_schema_options.py"    # Runtime options
            - "readers_schema_settings.py"   # Runtime settings

        tests:
          pattern: "test_<stage>_<module>.py"
          description: "Tests mirroring target modules"
          examples:
            - "test_readers_core_pdf.py"
            - "test_detect_type_pipeline.py"
            - "test_encoding_config.py"

        internal_helpers:
          pattern: "<stage>_helper_<topic>.py"
          description: "Local utilities"
          examples:
            - "readers_helper_textnorm.py"
            - "detect_type_detection_helper.py"

      main_layer:
        helpers:
          pattern: "main_pre_helpers_<topic>.py"
          description: "Cross-phase helpers"
          examples:
            - "main_pre_helpers_lang.py"
            - "main_pre_helpers_num.py"
            - "main_pre_helpers_logger.py"

        pipelines:
          pattern: "<purpose>_pipeline.py"
          description: "Multi-phase pipeline orchestration"
          examples:
            - "preprocessing_chain.py"
            - "detect_and_read.py"
            - "smoke_test_pipeline.py"

        schemas:
          pattern: "<entity>_schema.py"
          description: "Global schemas shared by multiple phases"
          examples:
            - "document_meta_schema.py"
            - "stage_contract_schema.py"

        tests:
          pattern: "test_<topic>.py"
          description: "Global tests for cross-phase helpers"
          examples:
            - "test_main_pre_helpers_lang.py"
            - "test_pipeline_integration.py"

    function_naming_rules:
      phase_functions:
        pattern: "<verb>_<stage>_<functionality>"
        description: "Phase-specific business logic functions"
        examples:
          - "process_readers_segment"
          - "compute_readers_table_bbox"
          - "record_readers_table_candidate"
          - "process_detect_type_classifier"  # Current pattern

      main_functions:
        pattern: "<verb>_main_pre_<topic>"
        description: "Cross-phase utility functions"
        examples:
          - "compute_main_pre_helpers_lang"
          - "process_main_pre_helpers_image"

      pipeline_functions:
        single_phase:
          pattern: "run_<stage>_pipeline"
          examples:
            - "run_readers_pipeline"
            - "run_detect_type_pipeline"
        multi_phase:
          pattern: "run_<purpose>_pipeline"
          examples:
            - "run_preprocessing_chain"
            - "run_detect_and_read"

  # === VALIDATION EXAMPLES ===
  validation_examples:
    phase_directory:
      valid_examples:
        - "phase_00_detect_type"
        - "phase_01_encoding"
        - "phase_02_readers"
      invalid_examples:
        - "phase_2_readers"  # Missing leading zero
        - "phase_02_readers_v2"  # Extra suffix not allowed
        - "Phase_02_Readers"  # Wrong case
    file_naming:
      valid_examples:
        - "reader_core_ocr.py"
        - "pipeline_readers_run.py"
        - "reader_output_schema.py"
        - "test_reader_core_ocr.py"
      invalid_examples:
        - "OCR_Reader.py"  # Wrong case and pattern
        - "reader.py"  # Missing stage prefix
        - "core_reader.py"  # Wrong pattern order
    function_naming:
      valid_examples:
        - "run_readers_extract"
        - "process_document_normalize"
        - "validate_input_check"
      invalid_examples:
        - "load_document"  # Contains forbidden term 'load'
        - "extractText"  # Wrong case
        - "process"  # Missing stage suffix

  # === PLACEHOLDER USAGE ===
  placeholder_usage:
    when_to_use: "During phase initialization and template generation"
    how_to_replace: "Use templating engine to substitute placeholders with actual values"
    examples:
      "{{PHASE_NAME}}": "Document Readers"
      "{{PHASE_ID}}": "phase_02_readers"
      "{{CREATED_AT}}": "2025-01-15T10:30:00Z"
      "{{AUTHOR}}": "Agent System"
      "{{INPUTS}}": "generic_items array"
      "{{OUTPUTS}}": "unified_document, stage_stats"
      "{{STANDARD_OUTPUT_PATH}}": "/path/to/outputs"
      "{{SAMPLE_OUTPUT_PATH}}": "/path/to/samples"
      "{{PHASE_VERSION}}": "1.0.0"
      "{{SCHEMA_VERSION}}": "1.0.0"
    templating_engine: "Use Jinja2 or similar templating system for placeholder substitution"

  # === CROSS-PHASE CODE DECISION TREE ===
  cross_phase_decision_tree:
    step_1:
      description: "Identify code purpose and scope"
      question: "Is this code used by more than one phase?"
      if_no: "Place in phase-specific folder"
      if_yes: "Continue to step 2"

    step_2:
      description: "Determine code category"
      categories:
        utility_functions:
          description: "Pure utility functions (math, text, file operations)"
          location: "core/preprocessing/cross_phase/helpers/"
          naming: "main_pre_helpers_<topic>.py"
          examples:
            - "Language processing utilities"
            - "Logging utilities"
            - "Geometry calculations"
            - "Number formatting"

        orchestration:
          description: "Multi-phase coordination and workflow management"
          location: "core/preprocessing/pipeline/"
          naming: "<purpose>_pipeline.py"
          examples:
            - "Full pipeline chains"
            - "Partial pipeline sequences"
            - "Testing pipelines"
            - "Validation workflows"

        data_structures:
          description: "Shared schemas, contracts, and type definitions"
          location: "core/preprocessing/cross_phase/schemas/"
          naming: "<entity>_schema.py"
          examples:
            - "Document metadata schemas"
            - "Stage contract definitions"
            - "Configuration schemas"
            - "Output format schemas"

        configuration:
          description: "Global settings and rules"
          location: "core/preprocessing/cross_phase/config/"
          naming: "<topic>_config.yaml"
          examples:
            - "Preprocessing rules"
            - "Pipeline configuration"
            - "Validation rules"
            - "Logging configuration"

        output_management:
          description: "Cross-phase output handling and routing"
          location: "core/preprocessing/output/"
          naming: "<functionality>_router.py"
          examples:
            - "Output directory management"
            - "Result aggregation"
            - "Export functionality"
            - "Output formatting"

        testing:
          description: "Cross-phase integration and system tests"
          location: "backend/Preprocessing/main_pre_tests/"
          naming: "test_<topic>.py"
          examples:
            - "Pipeline integration tests"
            - "Contract validation tests"
            - "Helper function tests"
            - "End-to-end tests"

        sample_data:
          description: "Test data and sample files"
          location: "main_pre_samples/"
          naming: "<type>_samples/"
          examples:
            - "PDF sample files"
            - "DOCX sample files"
            - "Image sample files"
            - "Smoke test samples"

    step_3:
      description: "Apply naming convention"
      utility_functions: "main_pre_helpers_<topic>.py"
      orchestration: "<purpose>_pipeline.py"
      data_structures: "<entity>_schema.py"
      configuration: "<topic>_config.yaml"
      output_management: "<functionality>_router.py"
      testing: "test_<topic>.py"
      sample_data: "<type>_samples/"

    step_4:
      description: "Place in appropriate folder"
      utility_functions: "core/preprocessing/cross_phase/helpers/"
      orchestration: "core/preprocessing/pipeline/"
      data_structures: "core/preprocessing/cross_phase/schemas/"
      configuration: "core/preprocessing/cross_phase/config/"
      output_management: "core/preprocessing/output/"
      testing: "backend/Preprocessing/main_pre_tests/"
      sample_data: "backend/Preprocessing/main_pre_samples/"

    step_5:
      description: "Add required documentation and tests"
      documentation:
        - "File header explaining cross-phase purpose"
        - "Function docstrings with usage examples"
        - "Integration notes for consuming phases"
      testing:
        - "Unit tests for utility functions"
        - "Integration tests for orchestration"
        - "Contract tests for schemas"
        - "Configuration validation tests"

  # === AGENT DECISION TREES ===
  agent_decision_trees:
    code_placement_decision:
      step_1:
        description: "Identify the code's scope"
        question: "Will this code be reused by more than one phase?"
        if_no: "Place in phase-specific folder"
        if_yes: "Place in main-layer folder"

      step_2:
        description: "Determine the code type"
        options:
          - "Business logic ‚Üí core_functions/"
          - "Orchestration ‚Üí pipeline_workflow/"
          - "External I/O ‚Üí connecters/"
          - "Types/validation ‚Üí schemas/"
          - "Tests ‚Üí tests/"
          - "Utilities ‚Üí helpers/"

      step_3:
        description: "Apply naming convention"
        phase_layer:
          core_functions: "<stage>_core_<functionality>.py"
          pipeline: "<stage>_pipeline.py"
          schemas: "<stage>_types.py"
          tests: "test_<stage>_<module>.py"
        main_layer:
          helpers: "main_pre_helpers_<topic>.py"
          pipelines: "<purpose>_pipeline.py"
          schemas: "<entity>_schema.py"
          tests: "test_<topic>.py"

      step_4:
        description: "Place in appropriate folder structure"
        phase_specific:
          - "phase_XX_<stage>/core_functions/"
          - "phase_XX_<stage>/pipeline_workflow/"
          - "phase_XX_<stage>/schemas/"
          - "phase_XX_<stage>/tests/"
        cross_phase:
          - "core/preprocessing/cross_phase/helpers/"
          - "core/preprocessing/cross_phase/schemas/"
          - "core/preprocessing/pipeline/"
          - "backend/Preprocessing/main_pre_tests/"

      step_5:
        description: "Add required documentation and tests"
        documentation:
          - "File header with module description"
          - "Function docstrings"
          - "Inline comments for complex logic"
        testing:
          - "Unit tests for core functions"
          - "Integration tests for workflows"
          - "Error condition tests"

    pipeline_creation_decision:
      question: "Does this pipeline orchestrate multiple phases?"
      if_single_phase:
        location: "phase_XX_<stage>/pipeline_workflow/"
        naming: "<stage>_pipeline.py"
        purpose: "Single phase orchestration"
        responsibilities:
          - "Load phase configuration"
          - "Connect to upstream data"
          - "Call core functions"
          - "Save outputs"
          - "Handle phase-level errors"
      if_multi_phase:
        location: "core/preprocessing/pipeline/"
        naming: "<purpose>_pipeline.py"
        purpose: "Multi-phase coordination"
        responsibilities:
          - "Coordinate phase execution order"
          - "Pass data between phases"
          - "Handle cross-phase errors"
          - "Manage overall pipeline state"
          - "Provide unified CLI interface"

  # === MIGRATION STRATEGY ===
  migration_strategy:
    current_state_analysis:
      phase_00_detect_type:
        folder: "core_processors/"  # Needs migration
        files: ["detect_type_classifier_process.py"]
        target: "core_functions/"
        new_naming: "detect_type_core_classifier.py"

      phase_01_encoding:
        folder: "core_processors/"  # Needs migration
        files: ["encoding_normalization_process.py"]
        target: "core_functions/"
        new_naming: "encoding_core_normalizer.py"

      phase_02_readers:
        folder: "core_functions/"  # Already correct
        files: ["readers_core_*.py"]
        status: "COMPLIANT"

    migration_plan:
      step_1: "Rename core_processors/ to core_functions/ in phases 00-01"
      step_2: "Update file names to follow <stage>_core_<functionality>.py pattern"
      step_3: "Update imports and references"
      step_4: "Update tests to match new naming"
      step_5: "Validate all phases follow unified structure"

    backward_compatibility:
      note: "Maintain backward compatibility during migration"
      approach: "Gradual migration with deprecation warnings"

  # === CROSS-PHASE CODE EXAMPLES ===
  cross_phase_code_examples:
    utility_functions:
      file: "main_pre_helpers_lang.py"
      purpose: "Language processing utilities used by multiple phases"
      functions:
        - "normalise_lang(tag: str) -> str"
        - "collapse_doc_lang(doc_share: Dict[str, float]) -> str"
        - "tokenise_langs(text: str) -> Dict[str, int]"
      used_by: ["phase_01_encoding", "phase_02_readers", "phase_08_heavy_normalization"]

    orchestration:
      file: "preprocessing_chain.py"
      purpose: "Multi-phase pipeline orchestration"
      functions:
        - "run_preprocessing_chain()"
        - "_resolve_inputs(inputs: Sequence[str]) -> List[str]"
        - "_run_phase_sequence()"
      coordinates: ["phase_00_detect_type", "phase_01_encoding", "phase_02_readers"]

    output_management:
      file: "output_router.py"
      purpose: "Cross-phase output directory management"
      functions:
        - "OutputRouter class"
        - "get_stage_output_dir(stage: str) -> Path"
        - "get_all_phases_dir() -> Path"
      manages: ["All phase outputs", "Smoke test results", "Aggregated results"]

    configuration:
      file: "preprocessing_rules.yaml"
      purpose: "Global preprocessing configuration"
      content:
        - "Global validation rules"
        - "Cross-phase settings"
        - "Feature flags"
        - "Default parameters"
      applies_to: ["All phases", "Pipeline orchestration", "Output management"]

  # === AGENT QUICK START ===
  agent_quick_start:
    creating_new_phase:
      step_1: "Determine phase number and name (e.g., phase_03_segment)"
      step_2: "Create phase directory with all 12 required subfolders"
      step_3: "Copy common files from templates"
      step_4: "Implement core functions following <stage>_core_<functionality>.py pattern"
      step_5: "Add tests and documentation"
      step_6: "Validate against structure rules"
      step_7: "Test phase integration with pipeline"

    creating_pipeline:
      single_phase: "Place in phase_XX_<stage>/pipeline_workflow/ as <stage>_pipeline.py"
      multi_phase: "Place in core/preprocessing/pipeline/ as <purpose>_pipeline.py"

    creating_cross_phase_code:
      utility_functions: "Place in core/preprocessing/cross_phase/helpers/ as main_pre_helpers_<topic>.py"
      orchestration: "Place in core/preprocessing/pipeline/ as <purpose>_pipeline.py"
      data_structures: "Place in core/preprocessing/cross_phase/schemas/ as <entity>_schema.py"
      configuration: "Place in core/preprocessing/cross_phase/config/ as <topic>_config.yaml"
      output_management: "Place in core/preprocessing/output/ as <functionality>_router.py"
      testing: "Place in backend/Preprocessing/main_pre_tests/ as test_<topic>.py"
      sample_data: "Place in main_pre_samples/ as <type>_samples/"

  # === COMMON PITFALLS ===
  common_pitfalls:
    structure_violations:
      - "Putting cross-phase code in phase-specific folders"
      - "Missing required subfolders in phase directory"
      - "Using inconsistent naming patterns"
      - "Hardcoding values instead of using config"
      - "Creating single-phase pipelines in core/preprocessing/pipeline/"
      - "Creating multi-phase pipelines in phase folders"
      - "Using 'core_processors' instead of 'core_functions'"

    naming_mistakes:
      - "Using wrong case (OCR vs ocr)"
      - "Missing stage prefix in file names"
      - "Using forbidden terms like 'load' or 'loader'"
      - "Inconsistent naming between phase and main layers"
      - "Wrong naming pattern for cross-phase code"

    documentation_issues:
      - "Missing required documentation files"
      - "Not following documentation conventions"
      - "Outdated documentation after code changes"
      - "Missing docstrings in functions"
      - "Missing cross-phase integration notes"

    testing_problems:
      - "Tests not mirroring module structure"
      - "Missing test coverage for core functions"
      - "Not testing error conditions"
      - "Tests hardcoded instead of using fixtures"
      - "Missing integration tests for cross-phase code"

  # === SUCCESS CRITERIA ===
  success_criteria:
    phase_creation:
      structure:
        - "All 12 required folders present"
        - "Phase directory follows naming pattern"
        - "Required common files copied"
      code_quality:
        - "Naming conventions followed consistently"
        - "All functions have docstrings"
        - "Code follows layer separation principle"
        - "Configuration loaded from files"
      testing:
        - "Tests mirror module names"
        - "Core functions have test coverage"
        - "Error conditions tested"
        - "Tests pass validation"
      documentation:
        - "README with required sections"
        - "CHANGELOG updated"
        - "RUNBOOK for operations"
        - "Code comments follow guidelines"
      validation:
        - "Phase passes structure validation"
        - "No forbidden terms in code"
        - "File names match regex patterns"
        - "Integration tests pass"

    cross_phase_code_creation:
      structure:
        - "Placed in correct main folder"
        - "Follows appropriate naming pattern"
        - "Has proper documentation"
      functionality:
        - "Works across multiple phases"
        - "Has comprehensive tests"
        - "Follows cross-phase guidelines"
        - "Integrates properly with consuming phases"

  # === VALIDATION RULES FOR CROSS-PHASE CODE ===
  cross_phase_validation:
    utility_functions:
      - "Must be pure functions (no side effects)"
      - "Must not depend on phase-specific logic"
      - "Must have comprehensive docstrings"
      - "Must have unit tests"
      - "Must be stateless"

    orchestration:
      - "Must handle phase failures gracefully"
      - "Must provide clear error messages"
      - "Must support configuration overrides"
      - "Must have integration tests"
      - "Must document phase dependencies"

    data_structures:
      - "Must be versioned"
      - "Must have validation logic"
      - "Must be backward compatible"
      - "Must have migration paths"
      - "Must be well documented"

    configuration:
      - "Must be validated on load"
      - "Must have default values"
      - "Must support environment overrides"
      - "Must be documented"
      - "Must be versioned"

    output_management:
      - "Must handle concurrent access"
      - "Must provide atomic operations"
      - "Must have cleanup mechanisms"
      - "Must support different output formats"
      - "Must be configurable"

  # === QUICK REFERENCE FOR AGENTS ===
  agent_quick_reference:
    decision_question: "Is this code used by more than one phase?"

    if_yes_cross_phase:
      utility_functions: "core/preprocessing/cross_phase/helpers/main_pre_helpers_<topic>.py"
      orchestration: "core/preprocessing/pipeline/<purpose>_pipeline.py"
      data_structures: "core/preprocessing/cross_phase/schemas/<entity>_schema.py"
      configuration: "core/preprocessing/cross_phase/config/<topic>_config.yaml"
      output_management: "core/preprocessing/output/<functionality>_router.py"
      testing: "backend/Preprocessing/main_pre_tests/test_<topic>.py"
      sample_data: "main_pre_samples/<type>_samples/"

    if_no_phase_specific:
      core_functions: "phase_XX_<stage>/core_functions/<stage>_core_<functionality>.py"
      pipeline: "phase_XX_<stage>/pipeline_workflow/<stage>_pipeline.py"
      schemas: "phase_XX_<stage>/schemas/<stage>_schema_<type>.py"
      tests: "phase_XX_<stage>/tests/test_<stage>_<module>.py"

    naming_patterns:
      cross_phase_helpers: "main_pre_helpers_<topic>.py"
      cross_phase_pipelines: "<purpose>_pipeline.py"
      cross_phase_schemas: "<entity>_schema.py"
      cross_phase_configs: "<topic>_config.yaml"
      cross_phase_routers: "<functionality>_router.py"
      cross_phase_tests: "test_<topic>.py"
      cross_phase_samples: "<type>_samples/"
      phase_core_functions: "<stage>_core_<functionality>.py"
      phase_pipelines: "<stage>_pipeline.py"
      phase_connectors: "<stage>_connector_<type>.py"
      phase_schemas: "<stage>_schema_<type>.py"
      phase_tests: "test_<stage>_<module>.py"

  # === EXISTING CONTENT PRESERVED ===
  folders:
    required_subfolders:
    - üìë config
    - ‚öôÔ∏è pipeline_workflow
    - üîó connecters
    - üß† core_functions
    - üóÇ schemas
    - üì§ outputs
    - üõ† internal_helpers
    - üß™ tests
    - üìö docs
    - üñº assets
    - ‚ôªÔ∏è external_helpers
    - üóÉ common_files
    descriptions:
      config: YAML/JSON settings; feature flags; routing maps. No business logic or
        code.
      pipeline_workflow: Orchestration/entrypoints; step ordering; validation; error
        routing; calls core_functions.
      connecters: 'External I/O: APIs, DB adapters, storage clients, messaging. No
        domain rules.'
      core_functions: Business logic for the phase. Prefer pure/testable functions,
        no external calls.
      schemas: Typed contracts and validators (Pydantic/TypedDict/JSON Schema, enums,
        dataclasses).
      outputs: Official/standard results of this phase. Never write sample/test/demo
        outputs here.
      internal_helpers: Local utilities scoped to this phase only (logging wrappers,
        tiny text/time tools).
      tests: Unit/integration/contract tests; fixtures under tests/fixtures/.
      docs: 'Human-readable docs: README, runbooks, diagrams, change notes for the
        phase.'
      assets: Static non-code resources used by the phase (icons, prompts, small references).
      external_helpers: Reusable utilities across phases (fs ops, hashing, OCR wrappers,
        PDF tools, retries).
      common_files: Shared static artifacts (base configs, vocabularies, mappings,
        legal texts). No Python modules.
    icons:
      config: üìë
      pipeline_workflow: ‚öôÔ∏è
      connecters: üîó
      core_functions: üß†
      schemas: üóÇ
      outputs: üì§
      internal_helpers: üõ†
      tests: üß™
      docs: üìö
      assets: üñº
      external_helpers: ‚ôªÔ∏è
      common_files: üóÉ

  common_stage_files:
    purpose: "Essential phase files organized by category (minimal structure)"
    location: "phase_XX_<stage>/common_files/"
    structure:
      docs:
        purpose: "Phase-specific documentation (single source of truth)"
        required_files: ["README.md", "CHANGELOG.md"]
        notes: "No duplicate docs/ directory in phase root - this is the only location"
      git:
        purpose: "Git workflow files"
        files: ["Makefile", ".gitmessage"]
      configs:
        purpose: "Base configuration files"
        files: ["ENV.sample", "LOGGING_BASE.yaml", "SETTINGS_BASE.yaml"]
    notes:
      - "Template files with placeholders have been removed"
      - "Project-wide policies stored in core/policy/"
      - "Phase-specific implementations only in common_files/"
      - "Single source of truth for all phase documentation"
    migration_benefits:
      - "Eliminated ~110 duplicate template files across 11 phases"
      - "Reduced duplication from 11 copies to 1 source"
      - "Cleaner minimal phase structure"
      - "Easier maintenance and updates"

  policies:
    docs_conventions:
      file: DOCS_CONVENTIONS.yaml
      purpose: Documentation style/formatting and structure for all phases.
      solves: Inconsistent documentation across phases; unclear tone/format.
      results: Uniform, reviewable documentation with predictable structure.
      content:
        meta:
          version: 3
          id: docs_conventions
        docs_conventions:
          stage_readme_sections:
          - Purpose
          - Workflow
          - Outputs
          - How to Run
          - Latest Updates
          changelog_versioning: semver
          change_types:
            feat: minor
            fix: patch
            breaking: major
            default: patch
          link_policy:
            from_changelog_to_readme: true
            readme_anchor_format: '### <change_name> {#<slug>}'
          hint_language_policy:
            allowed_language: english
            violation_response: reject and request rewrite
            applies_to:
            - stage readme hints
            - documentation templates
            - inline helper text
      category: documentation
      schema_version: 1.0.0
      references: []
    language_policy:
      file: LANGUAGE_POLICY.yaml
      purpose: Defines allowed languages/localization rules and translation guidelines.
      solves: Ad-hoc language choices and inconsistent translations.
      results: Predictable language behavior and easier localization/auditing.
      content:
        meta:
          version: 1
          id: language_policy
        language_policy:
          allowed_language: english
          forbid_scripts:
          - arabic
          apply_to_extensions:
          - .py
          - .md
          - .yaml
          - .yml
          - .txt
          violation_message: Only English hints/text allowed; remove non-English content.
      category: documentation
      schema_version: 1.0.0
      references: []
    stage_contract:
      file: STAGE_CONTRACT.yaml
      purpose: Contract between stages (inputs/outputs)
      solves: Ambiguous interfaces between stages causing breakage
      results: Explicit stage contracts, safer refactoring
      content:
        meta:
          version: 3
          id: stage_contract
        stage_contract:
          inputs:
          - name: generic_items
            type: array
            description: Generic input collection
          outputs:
          - name: unified_document
            type: json
            description: Unified document payload
          - name: stage_stats
            type: json
            description: Aggregated stage metrics
          required_config_keys:
          - io.out_doc_path
          - io.out_stats_path
          coordinate_origin: top_left
      category: interfaces
      schema_version: 1.0.0
      references: []
    git_conventions:
      file: GIT_CONVENTIONS.yaml
      purpose: Extended git conventions beyond commit messages
      solves: Random git practices causing confusion
      results: Unified git behavior across repo
      content:
        meta:
          version: 3
          id: git_conventions
        git_conventions:
          commit_header_regex: '^(feat|fix|refactor|docs|test|chore|perf|build|ci)\([a-z0-9_-]+/phase_[0-9]{2}_[a-z0-9_]+\):
            .+'
          commit_template: '<type>(<repo>/<phase>_<stage>): <summary>


            - Problem: ...

            - Solution: ...

            - Benefit: ...


            Refs:'
          branches:
            stage_branch: stage/phase_XX_<stage>
            feature_branch: feat/phase_XX_<stage>/<short-name>
            fix_branch: fix/phase_XX_<stage>/<short-name>
            release_branch: release/vX.Y.Z
          pull_request_template_sections:
          - Title (match main commit)
          - Problem -> Solution -> Benefit
          - Impact scope (BREAKING? stages affected)
          - Validation (tests/validators)
      category: governance
      schema_version: 1.0.0
      references: []
    validation_rules:
      file: VALIDATION_RULES.yaml
      purpose: Validation criteria for data and stages
      solves: Hidden or inconsistent validation checks
      results: Explicit validation improves reliability
      content:
        meta:
          version: 3
          id: validation_rules
        validation:
          check_phase_dir_pattern: true
          check_required_subfolders: true
          check_file_names_regex: true
          check_stage_prefix_on_files: true
          check_forbidden_terms: true
          regex:
            phase_dir: phase_[0-9]{2}_[a-z0-9_]+$
            file_allowed: ^[a-z0-9_]+_[a-z0-9_]+\.py$
            function_allowed_strict: ^(run|connect|normalize|process|deduplicate|compute|aggregate|cluster|segment|index|anchor|to|from|validate|check|save|emit|summarize|record)_[a-z0-9]+_[a-z0-9]+$
            forbidden_terms: \bload(?:er)?\b
          required_main_directories:
            - "core/policy/"
            - "core/preprocessing/cross_phase/helpers/"
            - "core/preprocessing/cross_phase/schemas/"
            - "core/preprocessing/cross_phase/config/"
            - "core/preprocessing/pipeline/"
            - "core/preprocessing/output/"
            - "backend/Preprocessing/main_pre_tests/"
            - "main_pre_samples/"
          phase_structure_validation:
            forbidden_directories:
              - "docs/" # Only common_files/docs/ allowed
            required_subdirectories_in_common_files:
              - "docs/"
              - "git/"
              - "configs/"
      category: quality
      schema_version: 1.0.0
      references: []
    kpis:
      file: KPIS.yaml
      purpose: Key performance indicators to track for each stage
      solves: No metrics; can't measure progress or quality
      results: Track KPIs and improve performance
      content:
        meta:
          version: 3
          id: kpis
        kpis:
          common:
          - processed_items_count
          - avg_latency_per_unit_ms
          - low_confidence_ratio
          by_stage_type:
            aggregation:
            - deduplicated_items_count
            - conflicts_count
            cleaning:
            - normalized_tokens_count
            - fixed_hyphenations_count
            segmentation:
            - segments_count
      category: metrics
      schema_version: 1.0.0
      references: []

  agent_quick_rules:
  - Code lives in core_functions/; orchestration in pipeline_workflow/; external I/O
    in connecters/.
  - Define data shapes in schemas/ and validate at workflow edges.
  - Load configuration from config/; avoid hard-coded constants in logic.
  - Write runtime artifacts to outputs/ (standard mode) or to sample_output_path (samples
    mode).
  - 'Decide the layer FIRST: phase-layer for single-phase code; main-layer for cross-phase
    reuse.'
  - 'Phase-layer placement: core functions ‚Üí core_functions/, orchestration ‚Üí pipeline_workflow/,
    types ‚Üí schemas/, tests ‚Üí tests/.'
  - 'Main-layer placement: reusable helpers ‚Üí core/preprocessing/cross_phase/helpers/, shared types ‚Üí core/preprocessing/cross_phase/schemas/,
    global tests ‚Üí backend/Preprocessing/main_pre_tests/.'
  - Name files according to file_naming_rules; keep tests as test_<target>.py mirroring
    their modules.
  - Production artifacts go under core/preprocessing/output/; sample/demo artifacts go under
    main_pre_samples/ with phase/date/run subfolders.
  - 'Cross-phase code: Any code used by multiple phases belongs in main folders organized by purpose.'

  code_commenting_guidelines:
    purpose: Ensure every new code file and function is self-explanatory with concise,
      English-only hints.
    rules:
    - 'At the TOP of every source file: add a short header block describing the module''s
      main responsibility and how it fits in the phase.'
    - 'At the START of every new logical stage/section in code: add a comment line
      that explains what begins here and why.'
    - 'For EVERY function/method: provide a docstring explaining purpose, parameters,
      returns, raises, and side effects.'
    - Prefer short, high-signal comments over verbose prose. Keep comments updated
      along with code changes.
    - 'Use TODO:, FIXME:, and NOTE: tags consistently for follow-ups and caveats.'
    - Keep inline comments focused on non-obvious intent or domain rules; avoid stating
      the obvious.
    - Examples are encouraged in docstrings where helpful (minimal, executable if
      possible).
    - 'Choose the correct file header template based on the layer: use ''file_header_phase_layer''
      for phase code; ''file_header_main_layer'' for cross-phase helpers.'
    templates:
      file_header_phase_layer: '"""

        Module: <module_name>

        Layer: PHASE

        Phase: <phase_id> (<phase_name>)

        Role: <what this phase-specific module does>

        Inputs: <phase contracts/types if any>

        Outputs: <phase outputs/contracts if any>

        """'
      file_header_main_layer: '"""

        Module: <module_name>

        Layer: MAIN (Preprocessing)

        Role: <what this cross-phase helper does>

        Reused by: <list phases or say ALL>

        Notes: <any constraints or performance caveats>

        """'
      stage_separator: '# ==== <Stage/Section Name>: <what starts here and why> ===='
      function_docstring: "def <function>(<params>):\n    \"\"\"\n    Brief: <one-line\
        \ summary>\n\n    Args:\n        <param1> (<type>): <meaning>\n        <param2>\
        \ (<type>): <meaning>\n\n    Returns:\n        <type>: <what is returned>\n\
        \n    Raises:\n        <ExceptionType>: <when/why>\n\n    Notes:\n       \
        \ <side effects, performance caveats, links>\n\n    Example:\n        >>>\
        \ <function>(example)\n        <expected>\n    \"\"\"\n    ..."

  layering:
    layers:
      phase_layer:
        description: Code that is specific to a single phase lives INSIDE that phase
          directory (e.g., phase_02_readers). This includes business logic modules
          and phase-scoped schemas.
        folders:
        - phase_XX_<stage>/core_functions/
        - phase_XX_<stage>/pipeline_workflow/
        - phase_XX_<stage>/schemas/
        - phase_XX_<stage>/tests/
        naming_examples:
        - reader_core_ocr.py
        - reader_core_pdf.py
        - pipeline_readers_run.py
        - reader_output_schema.py
        - test_reader_core_ocr.py
      main_layer:
        description: Code that will be reused across MULTIPLE phases lives in the
          global Preprocessing layer.
        folders:
        - core/preprocessing/cross_phase/helpers/
        - core/preprocessing/cross_phase/schemas/
        - core/preprocessing/pipeline/
        - backend/Preprocessing/main_pre_tests/
        - core/preprocessing/cross_phase/config/
        - core/preprocessing/output/
        - backend/Preprocessing/main_pre_samples/
        naming_examples:
        - main_pre_helpers_lang.py
        - main_pre_helpers_num.py
        - main_pre_helpers_logger.py
        - main_pre_helpers_geom.py
    routing_decision_for_agent:
      question: Will this code be reused by more than one phase?
      if_no_phase_specific:
        place_under: phase_XX_<stage>/core_functions/ (or pipeline_workflow/ if orchestration)
        name_like: <stage>_core_<functionality>.py (e.g., reader_core_ocr.py)
        tests_go_to: phase_XX_<stage>/tests/test_<module>.py
        schemas_go_to: phase_XX_<stage>/schemas/<entity>_schema.py
      if_yes_cross_phase:
        place_under: core/preprocessing/cross_phase/helpers/ (or core/preprocessing/cross_phase/schemas/ if types)
        name_like: main_pre_helpers_<topic>.py (e.g., main_pre_helpers_lang.py)
        tests_go_to: backend/Preprocessing/main_pre_tests/test_<topic>.py
        schemas_go_to: core/preprocessing/cross_phase/schemas/<entity>_schema.py
      outputs_and_samples:
        production_outputs: core/preprocessing/output/ (official artifacts)
        samples_outputs: backend/Preprocessing/main_pre_samples/ (by phase/date/run)
